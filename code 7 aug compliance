import os
import re
import logging
import pymysql
import traceback
from typing import List, Optional, Dict, Any
from datetime import datetime, date, timedelta
import json
import calendar
import sqlparse
from langchain_community.utilities import SQLDatabase
from langchain_ollama import OllamaLLM
from langchain.chains import create_sql_query_chain

# --- CONFIGURATION ---

# Database connection details
COMPLIANCE_DB_CONFIG = {
    "name": "System Compliance",
    "db_config": {
        "host": "localhost",
        "user": "root",
        "password": "root123",
        "database": "EIS_n"
    },
    "include_tables": ["EISHome_compliance"],
}

# Improved security patterns to prevent dangerous operations while allowing legitimate questions.
# This focuses on command syntax rather than just keywords.
BLOCKED_PATTERNS = [
    # Prohibit SQL data modification/definition language
    r"\b(delete|drop|truncate|alter|update|insert|grant|revoke|create|rename)\b",
    
    # Block dangerous shell command execution patterns
    r"\b(rm|kill|reboot|shutdown|userdel|passwd|mkfs|dd)\s+-",  # Commands with flags
    r";\s*(rm|kill|reboot|shutdown|wget|curl)", # Command chaining
    r":\s*(){:|:&};:",  # Fork bomb
    
    # Block system modification commands
    r"\b(wget|curl|sudo|su)\s+",
    r"\b(chmod|chown)\s+[0-7]{3,4}",
    r"\b(mount|umount)\s+",
    r"\b(fdisk|parted)\s+/dev/",
    r"\b(iptables|ufw|firewall-cmd)\s+", # Specific firewall management tools
    r"\b(setenforce)\b", # SELinux modification
]

# --- CORE FUNCTIONS ---

def detect_yes_no_question(question: str) -> bool:
    """Detects if the question is likely to require a yes/no answer."""
    question_lower = question.lower().strip()
    yes_no_patterns = [
        r"\b(do|does|did|is|are|was|were|will|would|can|could|should|has|have|had)\b.*\?",
        r"\b(all|every|each).*\b(have|has|same|identical|similar)\b",
        r"\b(any|some).*\b(have|has|missing|lacking|contain)\b",
        r"\b(is there|are there|exists?)\b",
        r"\bwhether\b.*\b(all|any|same)\b"
    ]
    return any(re.search(pattern, question_lower) for pattern in yes_no_patterns)

def analyze_for_yes_no_answer(question: str, result: List[Dict]) -> Optional[str]:
    """Analyzes query results to formulate a direct yes/no answer."""
    if not result:
        return "**No** - No servers found matching the criteria."

    question_lower = question.lower()
    
    # Patterns for questions like "do all servers have the same X?"
    same_patterns = [
        (r"(all|every).*same.*kernel.*version", 'kernelVersion'),
        (r"(all|every).*same.*os.*version", 'osVersion'),
        (r"(all|every).*same.*ace.*version", 'aceVersion'),
        (r"(all|every).*same.*mq.*version", 'mqVersion'),
        (r"(all|every).*same.*ram", 'ram'),
        (r"(all|every).*same.*cpu.*core", 'cpuCore'),
        (r"(all|every).*same.*firewall.*status", 'firewall'),
        (r"(all|every).*same.*server.*role", 'server_role')
    ]
    for pattern, field in same_patterns:
        if re.search(pattern, question_lower) and field in result[0]:
            values = {record.get(field) for record in result if record.get(field) is not None}
            if not values:
                return f"**No** - No data available for the field '{field.replace('_', ' ')}'."
            if len(values) == 1:
                return f"**Yes** - All {len(result)} servers have the same {field.replace('_', ' ')}: {list(values)[0]}"
            else:
                return f"**No** - Servers have different {field.replace('_', ' ')} values: {', '.join(map(str, values))}"

    # Patterns for questions like "are all servers running X?"
    status_patterns = [
        (r"(all|every).*firewall.*(active|enabled|running)", 'firewall', ['active', 'enabled', 'running']),
        (r"(all|every).*dsagent.*(active|enabled|running)", 'dsAgent', ['active', 'enabled', 'running']),
        (r"(all|every).*splunk.*(active|enabled|running)", 'splunk', ['active', 'enabled', 'running']),
        (r"(all|every).*firewall.*(disabled|inactive|stopped)", 'firewall', ['disabled', 'inactive', 'stopped']),
    ]
    for pattern, field, expected_statuses in status_patterns:
        if re.search(pattern, question_lower) and field in result[0]:
            matching_servers = sum(1 for record in result if any(status.lower() in str(record.get(field, '')).lower() for status in expected_statuses))
            if matching_servers == len(result):
                return f"**Yes** - All {len(result)} servers have {field} in a '{'/'.join(expected_statuses)}' state."
            else:
                return f"**No** - Only {matching_servers} out of {len(result)} servers have {field} in a '{'/'.join(expected_statuses)}' state."

    # Patterns for questions like "does any server have X?"
    any_patterns = [
        (r"(any|some).*server.*(high|over|above).*cpu", 'cpu', lambda x: x > 80),
        (r"(any|some).*server.*(high|over|above).*memory", 'memory', lambda x: x > 80),
        (r"(any|some).*server.*firewall.*disabled", 'firewall', lambda x: 'disabled' in str(x).lower()),
        (r"(any|some).*server.*expired.*user", ['eisuserExpi', 'rootExpi'], lambda x: 'expired' in str(x).lower())
    ]
    for pattern, field, condition in any_patterns:
        if re.search(pattern, question_lower):
            if isinstance(field, list):
                matching_servers = sum(1 for record in result if any(condition(record.get(f, '')) for f in field))
            else:
                if field not in result[0]:
                    return f"**No** - The field '{field}' was not found in the data."
                matching_servers = sum(1 for record in result if record.get(field) is not None and condition(record.get(field)))
            
            if matching_servers > 0:
                return f"**Yes** - {matching_servers} out of {len(result)} servers match the criteria."
            else:
                return f"**No** - No servers match the criteria."

    if re.search(r"(is there|are there|exists?).*server", question_lower):
        return f"**Yes** - Found {len(result)} server(s) matching your criteria."

    return None

def get_comprehensive_date_context() -> Dict[str, Any]:
    """Generates a comprehensive dictionary of date context for the LLM."""
    current_date = date.today()
    current_year = current_date.year
    current_month = current_date.month
    month_names = {v.lower(): k for k, v in enumerate(calendar.month_name) if k}
    month_names.update({v.lower(): k for k, v in enumerate(calendar.month_abbr) if k})
    month_numbers = {v: k for k, v in calendar.month_name.__members__.items()}

    return {
        'current_date': current_date.strftime('%Y-%m-%d'),
        'current_year': current_year,
        'current_month': current_month,
        'current_month_name': month_numbers[current_month],
        'next_year': current_year + 1,
        'prev_year': current_year - 1,
        'month_names': month_names,
        'month_numbers': month_numbers,
    }

def preprocess_question(question: str) -> str:
    """Preprocesses the question to handle date patterns, including relative ones."""
    question_lower = question.lower().strip()
    date_ctx = get_comprehensive_date_context()
    extracted_info = {}
    
    # Handle relative date terms
    today = date.today()
    if "last month" in question_lower:
        last_month_date = today.replace(day=1) - timedelta(days=1)
        extracted_info = {'year': last_month_date.year, 'month': last_month_date.month}
    elif "this month" in question_lower:
        extracted_info = {'year': today.year, 'month': today.month}

    # Handle explicit month-year patterns (overwrites relative terms if present)
    month_year_pattern = r'\b(january|jan|february|feb|march|mar|april|apr|may|june|jun|july|jul|august|aug|september|sep|october|oct|november|nov|december|dec)[\s,]+(\d{4})\b'
    match = re.search(month_year_pattern, question_lower)
    if match:
        month_name, year_str = match.groups()
        extracted_info['month'] = date_ctx['month_names'][month_name]
        extracted_info['year'] = int(year_str)

    if extracted_info:
        addition = f" [EXTRACTED DATE CONTEXT: "
        if 'month' in extracted_info:
            month_name = date_ctx['month_numbers'].get(extracted_info['month'], '')
            addition += f"month={extracted_info['month']} ({month_name}) "
        if 'year' in extracted_info:
            addition += f"year={extracted_info['year']} "
        question += addition + "]"
        print(f"DEBUG - Enhanced question: {question}")

    return question

def get_sql_generation_prompt() -> str:
    """Generates the master prompt for the LLM to convert questions to SQL."""
    date_ctx = get_comprehensive_date_context()
    return f"""You are an expert SQL query generator for a MySQL System Compliance database.
**CURRENT DATE CONTEXT:**
- Today's date: {date_ctx['current_date']}
- Current year: {date_ctx['current_year']}
- Current month: {date_ctx['current_month_name']}

**DATABASE SCHEMA:**
Table: `EISHome_compliance` (all fields are VARCHAR or INT)
- Key Fields: `id`, `ip_address`, `server_role`, `osVersion`, `kernelVersion`, `aceVersion`, `mqVersion`, `ram` (GB), `cpuCore`, `cpu` (%), `memory` (%), `firewall`, `dsAgent`, `splunk`, `eisuserExpi`, `rootExpi`.

**CRITICAL SQL GENERATION RULES:**
1.  ONLY generate `SELECT` statements. All other statement types are forbidden.
2.  Your response MUST consist of ONLY the raw SQL query. Do not include markdown, explanations, or any other text.
3.  Always use the exact table name: `EISHome_compliance`. Use backticks `` around table and column names.
4.  For all text fields (`VARCHAR`), use `LIKE '%search_term%'` for flexible matching.
5.  For numeric fields (`INT`), use standard operators (`=`, `>`, `<`, `>=`, `<=`).
6.  For questions about "all servers" or "any server" (Yes/No questions), select the specific columns mentioned in the question to allow for analysis. For example, for "do all servers have the same kernel version?", generate `SELECT `kernelVersion` FROM `EISHome_compliance`;`.
7.  Never add a `LIMIT` clause unless explicitly asked in the user's question.

**COMMON QUERY EXAMPLES:**
- "servers with high CPU": `SELECT * FROM `EISHome_compliance` WHERE `cpu` > 80;`
- "web servers": `SELECT * FROM `EISHome_compliance` WHERE `server_role` LIKE '%web%';`
- "firewall disabled": `SELECT * FROM `EISHome_compliance` WHERE `firewall` LIKE '%disabled%' OR `firewall` LIKE '%inactive%';`
- "expired users": `SELECT * FROM `EISHome_compliance` WHERE `eisuserExpi` LIKE '%expired%' OR `rootExpi` LIKE '%expired%';`
- "count servers by role": `SELECT `server_role`, COUNT(*) as count FROM `EISHome_compliance` GROUP BY `server_role`;`

**USER QUESTION:** {{question}}
"""

def is_dangerous(text: str) -> bool:
    """Checks if the input text contains potentially harmful patterns."""
    return any(re.search(pattern, text.lower()) for pattern in BLOCKED_PATTERNS)

def clean_and_fix_sql(raw_sql: str) -> str:
    """Cleans and extracts a single SQL query from raw LLM output."""
    print(f"DEBUG - Raw SQL input: {repr(raw_sql)}")

    if "i cannot" in raw_sql.lower() or "i can't" in raw_sql.lower():
        return "ERROR: LLM refused to generate SQL"

    # Extract SQL from markdown code blocks, e.g., ```sql\nSELECT ...\n```
    code_block_match = re.search(r"```(?:sql)?\s*(.*?)\s*```", raw_sql, re.DOTALL | re.IGNORECASE)
    sql = code_block_match.group(1).strip() if code_block_match else raw_sql.strip()
    
    # Remove conversational text and metadata that might slip through
    sql = re.sub(r"^(.*SQLQuery:\s*)?", "", sql, flags=re.IGNORECASE).strip()
    sql = re.sub(r'[;\s]*$', '', sql)

    # Ensure the statement is a SELECT statement.
    if not sql.upper().startswith('SELECT'):
        return f"ERROR: Generated query is not a SELECT statement. Query: {sql}"

    print(f"DEBUG - Final cleaned SQL: {sql}")
    return sql

def format_query_results_natural(result: List[Dict], question: str) -> str:
    """Formats query results into a user-friendly, natural language response."""
    if detect_yes_no_question(question):
        yes_no_answer = analyze_for_yes_no_answer(question, result)
        if yes_no_answer:
            response = yes_no_answer + "\n"
            if result and len(result) > 1: # Add supporting details for Yes/No answers
                response += "\n"
                if len(result) <= 10:
                    response += "📋 **Supporting Details:**\n"
                    response += format_query_results_tabular(result)
                else:
                    response += f"📋 **Supporting Details** (showing first 5 of {len(result)} servers):\n"
                    response += format_query_results_tabular(result[:5])
                    response += f"\n... and {len(result) - 5} more servers."
            return response

    if not result:
        return "I couldn't find any system compliance records matching your criteria."

    # Handle single value results (e.g., from COUNT(*))
    if len(result) == 1 and len(result[0]) == 1:
        key, value = list(result[0].items())[0]
        return f"The result is: **{value}**"

    # Handle single server record
    if len(result) == 1:
        record = result[0]
        response = "I found 1 server with the following details:\n\n"
        icons = {'id': '🆔', 'ip_address': '🌐', 'server_role': '🏷️', 'osVersion': '💿', 'ram': '🧠', 'cpuCore': '⚡', 'firewall': '🔥', 'dsAgent': '🛡️', 'cpu': '🖥️', 'memory': '💾', 'kernelVersion': '🔧'}
        for field, value in record.items():
            if value is not None:
                icon = icons.get(field, '•')
                field_name = field.replace('_', ' ').title()
                unit = " GB" if field == 'ram' else "%" if field in ['cpu', 'memory'] else ""
                response += f"{icon} **{field_name}:** {value}{unit}\n"
        return response.strip()

    # Handle multiple records with summary and tabular data
    response = f"I found **{len(result)}** servers matching your criteria.\n\n"
    if 'server_role' in result[0]:
        role_counts = {}
        for r in result:
            role = r.get('server_role', 'Unknown')
            role_counts[role] = role_counts.get(role, 0) + 1
        if len(role_counts) > 1:
            response += "🏷️ **Server Role Summary:**\n" + "".join(f"   • {role}: {count} servers\n" for role, count in sorted(role_counts.items())) + "\n"
    
    response += "📋 **Detailed Results:**\n"
    response += format_query_results_tabular(result[:10]) # Show top 10 results
    if len(result) > 10:
        response += f"\n... and {len(result) - 10} more servers."
        
    return response

def format_query_results_tabular(result: List[Dict]) -> str:
    """Formats a list of dictionary records into a clean text-based table."""
    if not result: return "No records found."
    
    important_cols = ['id', 'ip_address', 'server_role', 'osVersion', 'ram', 'cpuCore', 'firewall', 'dsAgent', 'cpu', 'memory', 'kernelVersion']
    headers = [col for col in important_cols if col in result[0]]
    if not headers: headers = list(result[0].keys())[:8]

    col_widths = {h: max(len(h), max((len(str(r.get(h, ''))) for r in result), default=0)) for h in headers}
    
    header_line = " | ".join(h.ljust(col_widths[h]) for h in headers)
    separator = "-+-".join("-" * col_widths[h] for h in headers)
    rows = [header_line, separator]
    for row in result:
        rows.append(" | ".join(str(row.get(h, 'NULL')).ljust(col_widths[h]) for h in headers))
        
    return "\n".join(rows)

# --- MAIN APPLICATION CLASS ---

class SystemComplianceAssistant:
    def __init__(self):
        self.llm = None
        self.db_handler = None
        self.initialized = False
        # Setup logging
        logging.basicConfig(filename=os.path.expanduser("~/.system_compliance_ai.log"), level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger(__name__)

    def initialize(self) -> bool:
        """Initializes the LLM and database connection."""
        if self.initialized: return True
        try:
            self.llm = OllamaLLM(model="myllm:latest", temperature=0.0)
            db_cfg = COMPLIANCE_DB_CONFIG['db_config']
            uri = f"mysql+pymysql://{db_cfg['user']}:{db_cfg['password']}@{db_cfg['host']}/{db_cfg['database']}"
            db_for_llm = SQLDatabase.from_uri(uri, include_tables=COMPLIANCE_DB_CONFIG["include_tables"])
            chain = create_sql_query_chain(self.llm, db_for_llm)
            db_conn = pymysql.connect(
                host=db_cfg['host'], user=db_cfg['user'], password=db_cfg['password'],
                database=db_cfg['database'], charset='utf8mb4', cursorclass=pymysql.cursors.DictCursor,
                connect_timeout=30, read_timeout=60
            )
            self.db_handler = {'chain': chain, 'connection': db_conn}
            self.initialized = True
            return True
        except Exception as e:
            self.logger.error(f"Initialization failed: {e}\n{traceback.format_exc()}")
            return False

    def query_system_compliance(self, question: str) -> str:
        """Handles the end-to-end process of converting a question to a formatted result."""
        if not self.db_handler:
            return "❌ System Compliance database not available."
        try:
            print(f"DEBUG - Original question: {question}")
            enhanced_question = preprocess_question(question)
            
            # Create a comprehensive context for the LLM prompt
            prompt_context = {"question": enhanced_question}
            
            # Generate SQL using the LLM chain with retries
            raw_sql = ""
            for attempt in range(3):
                try:
                    print(f"DEBUG - Attempt {attempt + 1} to generate SQL")
                    raw_sql = self.db_handler['chain'].invoke(prompt_context)
                    break
                except Exception as e:
                    if attempt == 2:
                        self.logger.error(f"SQL generation failed after multiple attempts: {e}")
                        return f"❌ Failed to generate SQL query: {e}"
            
            # Clean the generated SQL and check for errors
            sql = clean_and_fix_sql(raw_sql)
            if sql.startswith("ERROR:"):
                return f"❌ Failed to generate a valid SQL query. Reason: {sql}"
            if not sql.endswith(";"):
                sql += ";"
            
            print(f"DEBUG - Final SQL: {sql}")
            self.logger.info(f"Executing SQL: {sql}")
            
            # Execute the query against the database
            with self.db_handler['connection'].cursor() as cursor:
                cursor.execute(sql)
                result = cursor.fetchall()
                print(f"DEBUG - Query returned {len(result)} rows")
                
            # Format and return the final response
            return format_query_results_natural(result, question)

        except pymysql.Error as db_error:
            error_msg = f"❌ A database error occurred: {db_error}\nWhile executing SQL: `{sql}`"
            self.logger.error(f"Database error: {db_error}\nSQL: {sql}")
            return error_msg
        except Exception as e:
            self.logger.error(f"An unexpected error occurred: {e}\n{traceback.format_exc()}")
            return f"❌ An unexpected error occurred: {e}"

    def process_question(self, question: str) -> str:
        """Central processing function with security checks and initialization."""
        if not self.initialized and not self.initialize():
            return "❌ Assistant initialization failed. Please check logs and database connection."
        if is_dangerous(question):
            self.logger.warning(f"Blocked a potentially dangerous query: {question}")
            return "❌ Your question was blocked for security reasons as it contained a potentially harmful pattern."
        return self.query_system_compliance(question)

    def start_interactive_session(self, query: str):
        """Processes a single query and handles connection management."""
        if not self.initialize():
            return "❌ Failed to initialize System Compliance Assistant. Check database connection."
        try:
            response = self.process_question(query)
            return response
        except Exception as e:
            self.logger.error(f"Session error: {e}\n{traceback.format_exc()}")
            return f"❌ An error occurred during the session: {e}"
        finally:
            # Ensure the database connection is closed after the query
            if self.db_handler and self.db_handler.get('connection'):
                self.db_handler['connection'].close()
                self.initialized = False # Force re-initialization for the next call

def ComplianceMain(query: str) -> str:
    """Main entry point to process a single System Compliance query."""
    print("🚀 Starting System Compliance Assistant...")
    assistant = SystemComplianceAssistant()
    result = assistant.start_interactive_session(query)
    print("✅ Query processing complete.")
    return result

# --- INTERACTIVE COMMAND-LINE INTERFACE ---
if __name__ == "__main__":
    print("🚀 System Compliance Assistant 🚀")
    print("=" * 50)
    print("Ask questions about your system compliance database in natural language.")
    print("\nExamples:")
    print("  • 'Show servers with high CPU usage'")
    print("  • 'What is the firewall status for servers with more than 16GB RAM?'")
    print("  • 'Do all servers have the same kernel version?'")
    print("  • 'Are there any servers with a disabled firewall?'")
    print("  • 'Count servers by their OS version'")
    print("\nType 'exit' or 'quit' to end the session.\n")

    while True:
        try:
            user_query = input("🔍 Enter your query: ").strip()
            if not user_query: continue
            if user_query.lower() in ['exit', 'quit', 'q']:
                print("👋 Goodbye!")
                break

            print("\n🔄 Processing your query...")
            # Use the main function for processing
            result = ComplianceMain(user_query)
            print(f"\n📊 Assistant's Response:\n{result}\n")
            print("-" * 50)
        except KeyboardInterrupt:
            print("\n👋 Goodbye!")
            break
        except Exception as e:
            print(f"\n❌ A critical error occurred: {e}")
